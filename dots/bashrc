# If not running interactively, don't do anything
case $- in
	*i*) ;;
	*) return;;
esac

# Some stuff shouldn't be in this file
[ -e ~/.bash_secrets ] && source ~/.bash_secrets

# History stuff
HISTCONTROL=ignoreboth
shopt -s histappend
HISTSIZE=10000
HISTFILESIZE=100000

# Opts
shopt -s checkwinsize
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"

# I want colors in tmux...
if [ "$TERM" = screen ]; then
	export TERM=xterm-256color
fi

# Color config and aliases
if [ -x /usr/bin/dircolors ]; then
	test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
	alias ls='ls --color=auto'
	alias grep='grep --color=auto'
	alias fgrep='fgrep --color=auto'
	alias egrep='egrep --color=auto'
fi

# Aliases
alias vim=nvim
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias rscp='rsync -rclh --progress'

# Create a temp dir, spawn a shell there, delete when done
tmp() {
	local dir="$(mktemp -d "/tmp/$USER.tmp.XXXXXXXX")"
	(cd "$dir"; $SHELL)
	rm -rf "$dir"
}

# Make .. go up once, ... up twice, etc
dots() {
	for _ in $(seq 1 $1); do
		cd ..
	done
}
dots_acc="."
for i in $(seq 1 10); do
	dots_acc="$dots_acc."
	alias "$dots_acc"="dots $i"
done

# Env vars
export PATH="/usr/lib/go-1.13/bin:$HOME/go/bin:$HOME/.local/bin:$PATH"

# Enable programmable completion features
if ! shopt -oq posix; then
	if [ -f /usr/share/bash-completion/bash_completion ]; then
		. /usr/share/bash-completion/bash_completion
	elif [ -f /etc/bash_completion ]; then
		. /etc/bash_completion
	fi
fi

##
# Prompt
##

prompt_vc() {
	local x=$?

	local branch=$(git branch 2>/dev/null)
	if ! [ -z "$branch" ]; then
		printf '\001\033[31m\002%s' "$(echo "$branch" | grep '\* ' | sed 's/\* //')"
		if ! git diff --quiet --no-ext-diff; then
			printf '\001\033[1;33m\002*'
		fi
		printf ' '
	fi

	return $x
}

prompt_dollar() {
	local x=$?

	if [ $x = 0 ]; then
		printf '\001\033[32m\002$\001\033[0m\002 '
	else
		printf '\001\033[31m\002$\001\033[0m\002 '
	fi

	return $x
}

PS1='\[\033[01;32m\]\u\[\033[1;92m\]@\[\033[01;32m\]\h\[\033[00m\]: \[\033[01;34m\]\w\[\033[00m\] $(prompt_vc)$(prompt_dollar)'
